function e(e){for(var o=1;o<arguments.length;o++){var r=null!=arguments[o]?arguments[o]:{},a=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),a.forEach(function(o){t(e,o,r[o])})}return e}function t(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}const o=require("util"),r=require("chalk"),a=require("inquirer"),i=require("opn"),n=require("ora"),s=require("portscanner"),l=require("scp2"),u=require("webpack"),c=require("webpack-dev-server"),{openPath:p,proxy:d,successCb:m,uploadOpts:f}=require("../config/bruce"),{BUILD_TEXT:g}=require("../i18n"),{HOST:y,PORT:h,AbsPath:b,AsyncTo:q,BuildCb:w,CheckJsType:j,CheckPolyfill:k,GetUrl:P,IsExist:O,ShowInfo:S,ShowMsg:T,ShowTitle:B}=require("../util");module.exports=async function(){if(B("build"),!O("package.json"))return T("red",g.judgePackage);if(!O("node_modules"))return T("red",g.judgeModules);if(!O("dist/static"))return T("red",g.judgeDll);if(!O("src"))return T("red",g.judgeSrc);if("none"===j())return T("red",g.judgeType);if("ts"===j()&&!O("tsconfig.json"))return T("red",g.judgeTsconfig);const t={analyze:{default:!1,message:g.qaAnalyze,name:"analyze",type:"confirm"},compress:{default:!1,message:g.qaCompress,name:"compress",type:"confirm"},csslint:{default:!1,message:g.qaCsslint,name:"csslint",type:"confirm"},hash:{default:!1,message:g.qaHash,name:"hash",type:"confirm"},jslint:{default:!1,message:g.qaJslint,name:"jslint",type:"confirm"},mode:{choices:g.mode,default:0,message:g.qaMode,name:"mode",type:"list"},open:{default:!1,message:g.qaOpen,name:"open",type:"confirm"},output:{default:!1,message:g.qaOutput,name:"output",type:"confirm"},polyfill:{default:!1,message:g.qaPolyfill,name:"polyfill",type:"confirm"},port:{default:h,message:g.qaPort,name:"port",type:"input",validate:async e=>{const t=+e;return isNaN(t)||t%1!=0?r.redBright(g.judgePort):"open"!==await s.checkPortStatus(t,y)||r.redBright(g.judgeExist(t))}},timed:{default:!1,message:g.qaTimed,name:"timed",type:"confirm"},upload:{default:!1,message:r.redBright(g.qaUpload),name:"upload",type:"confirm"}},v=[t.mode],C=await a.prompt(v);C.mode=g.modeMap[C.mode];const x=C.mode,z=[];1===x?z.push(t.port,t.open,t.csslint,t.jslint):z.push(t.output,!k()&&t.polyfill,t.hash,t.compress,t.timed,t.analyze,t.upload);const A=e({},C,await a.prompt(z.filter(e=>e))),{open:E,port:F,upload:M}=A;if(1===x){const e=require("../config/webpack.dev"),t=u(e(A));new c(t,{contentBase:b("dist"),disableHostCheck:!0,historyApiFallback:!0,host:y,hot:!0,open:!0,overlay:!0,port:F,proxy:d,publicPath:P(F)+"/",quiet:!0}).listen(F,y,e=>{if(e)T("red",g.buildFail);else{const e=P(F,p),t=P(F,p,!0);console.log(r.yellowBright(g.listening)),console.log(g.listLocalhost+r.blueBright(e)),console.log(g.listNetwork+r.blueBright(t)),E&&i(e,{app:"chrome"})}})}else{S(A);const e=require("../config/webpack.prod")(A),[t,r]=await w(e);if(t||!r)T("red",g.buildFail);else if(T("green",g.buildSucceed),M&&m)m(x,e.output.path);else if(M&&f){const e=n(g.uploading),t=o.promisify(l.scp);e.start();const r={2:"testing",3:"production"}[x],[a]=await q(t(b(`dist/${r}`),f(r)));e.stop(),a?(console.log(a),T("red",g.uploadFail)):T("green",g.uploadSucceed)}}};